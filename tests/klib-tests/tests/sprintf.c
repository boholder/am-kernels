#include "../include/trap.h"
#include <limits.h>

// why divide by 17:
// 选择17作为除数，可以让测试用例既不是非常接近于2、4、8、16、32等二进制相关的数，
// 也不与10、100等十进制“常用”基数有关。
// 这样，INT_MAX / 17等数据会落在int范围的一个“非边界、不规则”位置——
// 它既不会是对齐整数的临界值，也不会容易被格式化代码的特定分支、特殊优化所掩盖。
static int INTS[] = {0, INT_MAX / 17, INT_MAX, INT_MIN, INT_MIN + 1,
                     UINT_MAX / 17, INT_MAX / 17, UINT_MAX};

// generated by glibc printf
static char STRS[][12] = {"0", "126322567", "2147483647", "-2147483648",
                          "-2147483647", "252645135", "126322567", "-1"};

static int ints_len = ARRLEN(INTS);
static int strs_len = ARRLEN(STRS);

void format_int()
{
  for (int i = 0; i < ints_len; i++) {
    char str[12];
    sprintf(str, "%d", INTS[i]);
    assert(strcmp(str, STRS[i]) == 0);
  }
}

void format_int_limit_len()
{
  // ignore 0 and -1 because they are not so long
  for (int i = 1; i < ints_len - 1; i++) {
    char str[12];
    int given_len = 5; // only print first 5 - 1 = 4 chars (and end with '\0')
    snprintf(str, given_len, "%d", INTS[i]);
    for (int j = 0; j < given_len - 1; j++) {
      assert(str[j] == STRS[i][j]);
    }
  }
}

void format_string()
{
  for (int i = 0; i < strs_len; i++) {
    char str[12];
    sprintf(str, "%s", STRS[i]);
    assert(strcmp(str, STRS[i]) == 0);
  }
}

void format_string_limit_len()
{
  for (int i = 1; i < strs_len - 1; i++) {
    char str[12];
    int given_len = 5; // only print first 4 chars (and end with '\0')
    snprintf(str, given_len, "%s", STRS[i]);
    for (int j = 0; j < given_len - 1; j++) {
      assert(str[j] == STRS[i][j]);
    }
  }
}

int main()
{
  assert(ints_len == strs_len);
  format_int();
  format_int_limit_len();
  format_string();
  format_string_limit_len();
}